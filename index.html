<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AI Virtual Terminal Sandbox</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-1: #1a1b26;
      --bg-2: #16161e;
      --panel: #222436;
      --accent: #7aa2f7;
      --accent-2: #bb9af7;
      --muted: #9aa5ce;
      --success: #9ece6a;
      --danger: #f7768e;
      --radius: 10px;
      --mono: 'Fira Code', monospace;
    }

    * { box-sizing: border-box; }
    html,body { height:100%; margin:0; font-family: Inter, system-ui, sans-serif; background:linear-gradient(160deg,var(--bg-1), var(--bg-2)); color:#e6e6fa; }

    .app { min-height:100vh; display:flex; flex-direction:column; gap:16px; padding:20px; }

    header.topbar {
      display:flex; align-items:center; gap:16px; padding:14px 18px; border-radius:var(--radius); background:var(--panel); border:1px solid rgba(255,255,255,0.06); box-shadow:0 6px 16px rgba(0,0,0,0.6);
    }

    .brand { display:flex; gap:12px; align-items:center; }
    .logo { width:42px; height:42px; border-radius:8px; display:grid; place-items:center; font-weight:700; background:linear-gradient(135deg,var(--accent),var(--accent-2)); color:#fff; font-family:var(--mono); font-size:14px; }
    .title { font-weight:600; font-size:15px; color:#eaf0ff; }
    .subtitle { font-size:12px; color:var(--muted); margin-top:2px; }

    .controls { margin-left:auto; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    input[type=password]#api-key-input { padding:8px 10px; border-radius:var(--radius); border:1px solid rgba(255,255,255,0.08); background:#1f2335; color:#fff; font-size:13px; font-family:var(--mono); min-width:280px; }

    .controls button, .controls a.btn {
      padding:8px 12px; border-radius:var(--radius); border:1px solid rgba(255,255,255,0.08); background:rgba(255,255,255,0.04); color:var(--accent); cursor:pointer; font-weight:600; font-size:13px; text-decoration:none; transition: all .15s ease; 
    }
    .controls button:hover, .controls a.btn:hover { background:var(--accent); color:#fff; }
    .controls button.primary { background:var(--success); color:#0f140a; border:none; }
    .controls .hint { font-size:12px; color:var(--muted); margin-left:10px; }

    main.shell-wrap { display:flex; gap:16px; }
    .panel { flex:1; background:var(--panel); border:1px solid rgba(255,255,255,0.08); border-radius:var(--radius); box-shadow:0 8px 24px rgba(0,0,0,0.5); overflow:hidden; }

    #term { flex:1; height:calc(100vh - 160px); padding:8px; font-family:var(--mono); }

    .sidebar { width:280px; display:flex; flex-direction:column; gap:12px; }
    .card { padding:14px; border-radius:var(--radius); background:#1f2335; border:1px solid rgba(255,255,255,0.05); }
    .card h4 { margin:0 0 8px; font-size:13px; font-weight:600; color:var(--accent-2); }
    .meta { font-size:13px; color:var(--muted); }

    .footer-note { font-size:12px; color:var(--muted); text-align:center; margin-top:10px; }

    /* Preserve newlines but allow wrapping so vertical lists are clean */
    .xterm .xterm-viewport { padding:8px !important; }
    .xterm .xterm-rows { font-family:var(--mono) !important; font-size:13px !important; white-space: pre-wrap !important; }

    @media(max-width:900px){ .sidebar{ display:none; } #term{ height:calc(100vh - 140px); } }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="logo">VT</div>
        <div>
          <div class="title">AI Virtual Terminal</div>
          <div class="subtitle">Minimal & Elegant Sandbox</div>
        </div>
      </div>

      <div class="controls">
        <input type="password" id="api-key-input" placeholder="OpenRouter API Key">
        <button id="btn-save-key" class="primary">Save Key</button>
        <a id="btn-download-py-compiler" class="btn" href="https://drive.google.com/uc?export=download&id=1G7Ci97q0Moxn-AJo4I9ElnsG_OnN3fZg" download>Download Compiler</a>
        <div class="hint">AI-enabled sandbox</div>
      </div>
    </header>

    <main class="shell-wrap">
      <section class="panel">
        <div id="term"></div>
      </section>

      <aside class="sidebar">
        <div class="card"><h4>Tips</h4><div class="meta">Use <code>help</code> for commands · Try natural language too.</div></div>
        <div class="card"><h4>Storage</h4><div class="meta">Files persist in localStorage until cleared.</div></div>
        <div class="card"><h4>Keys</h4><div class="meta">Up/Down — history · Tab — autocomplete</div></div>
      </aside>
    </main>

    
  </div>

  <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
  <script>
/* Full app JS (preserves your original features).
   Important formatting changes: returns use '\r\n' for line breaks
   and all suggestion lists use '\r\n' so xterm displays them vertically.
*/

const FS_STORAGE_KEY = 'browser_sandbox_fs_v1';
const API_KEY_STORAGE_KEY = 'openrouter_api_key_v1';
const HOME = '/home/user'; // virtual home
const PROMPT_COLOR = '\x1b[32m'; // green
const AI_COLOR = '\x1b[36m'; // cyan
const ERROR_COLOR = '\x1b[31m'; // red
const RESET_COLOR = '\x1b[0m';

const term = new Terminal({ cols: 100, rows: 30, cursorBlink: true });
term.open(document.getElementById('term'));

function initialFs() {
  const tree = {};
  tree['/'] = { type: 'dir', children: { 'home': true } };
  tree['/home'] = { type: 'dir', children: { 'user': true } };
  tree['/home/user'] = { type: 'dir', children: {} };
  tree['/home/user/README.txt'] = { type: 'file', content: 'This is a browser-only sandbox. Files are saved in localStorage.\r\nUse `help` to list commands.\r\nIf you type a sentence that is not a command, AI will try to generate a command for you.\r\n' };
  return { cwd: HOME, tree };
}

function loadFs() {
  try {
    const raw = localStorage.getItem(FS_STORAGE_KEY);
    if (!raw) {
      const fs0 = initialFs();
      saveFs(fs0);
      return fs0;
    }
    return JSON.parse(raw);
  } catch (e) {
    console.error('loadFs error', e);
    const fs0 = initialFs();
    saveFs(fs0);
    return fs0;
  }
}

function saveFs(fs) {
  localStorage.setItem(FS_STORAGE_KEY, JSON.stringify(fs));
}

function resolvePath(cwd, path) {
  if (!path) return cwd;
  if (path.startsWith('/')) {
  } else {
    if (cwd === '/') path = '/' + path;
    else path = cwd + '/' + path;
  }
  const parts = path.split('/').filter(Boolean);
  const stack = [];
  for (const p of parts) {
    if (p === '.') continue;
    if (p === '..') { if (stack.length) stack.pop(); continue; }
    stack.push(p);
  }
  return '/' + stack.join('');
}

function pathExists(tree, p) {
  if (p === '') p = '/';
  return tree.hasOwnProperty(p);
}
function isDir(tree, p) { return pathExists(tree, p) && tree[p].type === 'dir'; }
function isFile(tree, p) { return pathExists(tree, p) && tree[p].type === 'file'; }
function parentPath(p) {
  if (p === '/') return null;
  const idx = p.lastIndexOf('/');
  if (idx === 0) return '/';
  return p.substring(0, idx);
}
function baseName(p) {
  if (p === '/') return '/';
  const idx = p.lastIndexOf('/');
  return p.substring(idx+1);
}

let fs = loadFs();

function listDir(p) {
  if (!isDir(fs.tree, p)) return { err: 'Not a directory' };
  const node = fs.tree[p];
  const names = Object.keys(node.children || {});
  names.sort();
  return names;
}

function makeDir(p) {
  if (pathExists(fs.tree, p)) return { err: 'File or directory exists' };
  const parent = parentPath(p);
  if (!parent || !isDir(fs.tree, parent)) return { err: 'No such directory: ' + parent };
  fs.tree[p] = { type: 'dir', children: {} };
  fs.tree[parent].children[baseName(p)] = true;
  saveFs(fs);
  return {};
}

function removePath(p, recursive=false) {
  if (!pathExists(fs.tree, p)) return { err: `No such file or directory: ${p}` };
  if (isDir(fs.tree, p)) {
    const children = Object.keys(fs.tree[p].children || {});
    if (children.length && !recursive) return { err: 'Directory not empty (use -r flag)' };
    const keys = Object.keys(fs.tree);
    for (const k of keys) {
      if (k === p || k.startsWith(p + '/')) delete fs.tree[k];
    }
    const parent = parentPath(p);
    if (parent && fs.tree[parent]) delete fs.tree[parent].children[baseName(p)];
    saveFs(fs);
    return {};
  } else {
    const parent = parentPath(p);
    delete fs.tree[p];
    if (parent && fs.tree[parent]) delete fs.tree[parent].children[baseName(p)];
    saveFs(fs);
    return {};
  }
}

function writeFile(p, content, append=false) {
  const parent = parentPath(p);
  if (!parent || !isDir(fs.tree, parent)) return { err: 'No such directory: ' + parent };
  if (!pathExists(fs.tree, p)) {
    fs.tree[p] = { type: 'file', content: content || '' };
    fs.tree[parent].children[baseName(p)] = true;
  } else {
    if (!isFile(fs.tree, p)) return { err: 'Not a file' };
    if (append) fs.tree[p].content += content;
    else fs.tree[p].content = content;
  }
  saveFs(fs);
  return {};
}

function readFile(p) {
  if (!pathExists(fs.tree, p)) return { err: 'No such file' };
  if (!isFile(fs.tree, p)) return { err: 'Not a file' };
  return { content: fs.tree[p].content };
}

function movePath(src, dst) {
  if (!pathExists(fs.tree, src)) return { err: 'No such file or directory: ' + src };
  const dstParent = isDir(fs.tree, dst) ? dst : parentPath(dst);
  if (!dstParent || !isDir(fs.tree, dstParent)) return { err: 'Destination directory does not exist' };
  const finalDst = isDir(fs.tree, dst) ? resolvePath(dst, baseName(src)) : dst;
  if (pathExists(fs.tree, finalDst)) return { err: 'Destination already exists' };
  
  const keys = Object.keys(fs.tree);
  for (const k of keys) {
    if (k === src || k.startsWith(src + '/')) {
      const rel = k.substring(src.length);
      const newkey = finalDst + rel;
      fs.tree[newkey] = fs.tree[k];
      delete fs.tree[k];
    }
  }
  const srcParent = parentPath(src);
  if (srcParent && fs.tree[srcParent]) delete fs.tree[srcParent].children[baseName(src)];
  fs.tree[dstParent].children[baseName(finalDst)] = true;
  saveFs(fs);
  return {};
}

/* ------------------ command handlers ------------------ */

const COMMANDS = {
    'pwd': cmd_pwd, 'ls': cmd_ls, 'cd': cmd_cd, 'mkdir': cmd_mkdir,
    'touch': cmd_touch, 'cat': cmd_cat, 'echo': cmd_echo, 'rm': cmd_rm,
    'mv': cmd_mv, 'clear': cmd_clear, 'help': cmd_help, 'ps': cmd_ps
};

function cmd_pwd(args) { return fs.cwd; }
function cmd_ls(args) {
  const target = args[0] ? resolvePath(fs.cwd, args[0]) : fs.cwd;
  if (!isDir(fs.tree, target)) {
    if (isFile(fs.tree, target)) return baseName(target);
    return `ls: cannot access '${target}': No such file or directory`;
  }
  const names = listDir(target);
  // Vertical list: use CRLF explicit line breaks so terminal renders one per line
  return names.join('\r\n');
}
function cmd_cd(args) {
  const target = args[0] ? resolvePath(fs.cwd, args[0]) : HOME;
  if (!pathExists(fs.tree, target)) return `cd: no such file or directory: ${args[0] || target}`;
  if (!isDir(fs.tree, target)) return `cd: not a directory: ${args[0] || target}`;
  fs.cwd = target;
  saveFs(fs);
  return '';
}
function cmd_mkdir(args) {
  if (!args[0]) return 'mkdir: missing operand';
  const p = resolvePath(fs.cwd, args[0]);
  const r = makeDir(p);
  if (r.err) return `mkdir: ${r.err}`;
  return '';
}
function cmd_touch(args) {
  if (!args[0]) return 'touch: missing file operand';
  const p = resolvePath(fs.cwd, args[0]);
  const r = writeFile(p, '', false);
  if (r.err) return `touch: ${r.err}`;
  return '';
}
function cmd_cat(args) {
  if (!args[0]) return 'cat: missing file operand';
  const p = resolvePath(fs.cwd, args[0]);
  const r = readFile(p);
  if (r.err) return `cat: ${r.err}`;
  return r.content;
}
function cmd_echo(args) {
  if (args.length === 0) return '';
  const redirectIndex = args.indexOf('>');
  if (redirectIndex !== -1) {
    const text = args.slice(0, redirectIndex).join(' ');
    const file = args[redirectIndex+1];
    if (!file) return 'echo: no file specified for redirect';
    const p = resolvePath(fs.cwd, file);
    const w = writeFile(p, text + '\r\n', false);
    if (w.err) return `echo: ${w.err}`;
    return '';
  }
  return args.join(' ');
}
function cmd_rm(args) {
  if (!args[0]) return 'rm: missing operand';
  const recursive = args.includes('-r') || args.includes('-R');
  const targets = args.filter(a => a !== '-r' && a !== '-R');
  let out = '';
  for (const t of targets) {
    const p = resolvePath(fs.cwd, t);
    const r = removePath(p, recursive);
    if (r.err) out += `rm: ${r.err}\r\n`;
  }
  return out.trim();
}
function cmd_mv(args) {
  if (args.length !== 2) return 'mv: requires source and destination';
  const src = resolvePath(fs.cwd, args[0]);
  const dst = resolvePath(fs.cwd, args[1]);
  const r = movePath(src, dst);
  if (r.err) return `mv: ${r.err}`;
  return '';
}
function cmd_clear() { term.clear(); return ''; }
function cmd_help() {
  return [
    'Supported commands (virtual):',
    'ls, pwd, cd, mkdir, touch, cat, echo, rm, mv, ps, clear, help',
    '',
    'Natural Language to Command:',
    'If your input is not a recognized command, it will be sent to an AI to generate a command suggestion.',
    'An OpenRouter API key must be saved in the controls above for this feature to work.'
  ].join('\r\n');
}
function cmd_ps() {
  const simulated = [ { pid: 1, user: 'root', name: 'init' }, { pid: 1337, user: 'user', name: 'virtual-shell' }, { pid: 9999, user: 'user', name: 'xterm-js' } ];
  let out = `${'PID'.padEnd(8)}${'USER'.padEnd(10)}NAME\r\n${'-'.repeat(30)}\r\n`;
  for (const p of simulated) { out += `${String(p.pid).padEnd(8)}${p.user.padEnd(10)}${p.name}\r\n`; }
  return out;
}


/* ------------------ AI command generation ------------------ */

async function generateCommandFromPrompt(prompt) {
    const apiKey = localStorage.getItem(API_KEY_STORAGE_KEY);
    if (!apiKey) {
        return { err: 'OpenRouter API key not set. Please add it in the controls above.' };
    }
    
    term.write(' (asking AI...)');

    try {
        const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({
                "model": "mistralai/mistral-7b-instruct",
                "messages": [
                    {
                        "role": "system",
                        "content": "You are an expert in shell commands for a virtual terminal. Convert the user's request into a single, executable command. The available commands are: ls, pwd, cd, mkdir, touch, cat, echo, rm, mv, ps. Provide only the command and nothing else. Do not add explanations or markdown."
                    },
                    { "role": "user", "content": prompt }
                ]
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            return { err: `API Error: ${errorData.error?.message || response.status}` };
        }

        const data = await response.json();
        const command = data.choices[0].message.content.trim().replace(/^`+|`+$/g, '');
        return { command };

    } catch (error) {
        return { err: `Network error: ${error.message}` };
    }
}

/* ------------------ REPL input handling ------------------ */

let commandHistory = [];
let historyIndex = -1;

function getPromptString() {
    const displayPath = fs.cwd;
    return PROMPT_COLOR + displayPath + RESET_COLOR + '$ ';
}

function printPrompt() {
  term.write('\r\n' + getPromptString());
}

let inputBuffer = '';
term.write('Welcome! Type `help` for commands or a sentence to get an AI command suggestion.\r\n');
term.write(getPromptString());

term.onKey(async (e) => {
    const ev = e.domEvent;

    switch (ev.key) {
        case 'Enter':
            term.write('\r\n');
            await handleCommand(inputBuffer.trim());
            inputBuffer = '';
            break;
        
        case 'Backspace':
            if (inputBuffer.length > 0) {
                term.write('\b \b');
                inputBuffer = inputBuffer.slice(0, -1);
            }
            break;
            
        case 'ArrowUp':
            if (historyIndex < commandHistory.length - 1) {
                historyIndex++;
                inputBuffer = commandHistory[commandHistory.length - 1 - historyIndex];
                term.write('\x1b[2K\r' + getPromptString() + inputBuffer);
            }
            break;
            
        case 'ArrowDown':
            if (historyIndex > 0) {
                historyIndex--;
                inputBuffer = commandHistory[commandHistory.length - 1 - historyIndex];
                term.write('\x1b[2K\r' + getPromptString() + inputBuffer);
            } else {
                historyIndex = -1;
                inputBuffer = '';
                term.write('\x1b[2K\r' + getPromptString());
            }
            break;

        case 'Tab':
            ev.preventDefault();
            handleAutocomplete();
            break;

        default:
            if (e.key.length === 1 && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
                inputBuffer += e.key;
                term.write(e.key);
            }
    }
});


async function handleCommand(line) {
  if (!line) { 
    term.write(getPromptString());
    return;
  }
  
  if(line && (!commandHistory.length || commandHistory[commandHistory.length-1] !== line)) {
      commandHistory.push(line);
  }
  historyIndex = -1;

  const tokens = splitArgs(line);
  const cmd = tokens[0];
  const args = tokens.slice(1);
  
  if (COMMANDS[cmd]) {
      const output = COMMANDS[cmd](args);
      if(output) term.write(output);
      if (cmd !== 'clear') printPrompt();
  } else {
      const aiResult = await generateCommandFromPrompt(line);
      if (aiResult.err) {
          term.write(ERROR_COLOR + aiResult.err + RESET_COLOR);
          printPrompt();
      } else {
          // show AI suggestion then execute
          term.write(`${AI_COLOR}AI Suggestion: ${RESET_COLOR}${aiResult.command}\r\n`);
          await handleCommand(aiResult.command);
      }
  }
}

function handleAutocomplete() {
    const parts = inputBuffer.split(' ');
    const currentPart = parts[parts.length - 1];
    
    let potentialMatches = [];
    if (parts.length === 1) {
        // Autocomplete commands
        potentialMatches = Object.keys(COMMANDS).filter(cmd => cmd.startsWith(currentPart));
    } else {
        // Autocomplete file/directory paths
        const currentDir = parts.length > 2 ? resolvePath(fs.cwd, parts.slice(0, -1).join(' ')) : fs.cwd;
        const dir = listDir(currentDir);

        if(typeof dir.join === 'function') {
           potentialMatches = dir.filter(name => name.startsWith(currentPart));
        }
    }

    if (potentialMatches.length === 1) {
        const match = potentialMatches[0];
        const completion = match.substring(currentPart.length);
        inputBuffer += completion;
        term.write(completion);
    } else if (potentialMatches.length > 1) {
        // Print suggestions vertical (CRLF)
        term.write('\r\n' + potentialMatches.join('\r\n') + '\r\n');
        printPrompt();
        term.write(inputBuffer);
    }
}

/* simple argument splitter supporting quotes */
function splitArgs(s) {
  const res = []; let current = ''; let inQuotes = false; let quoteChar = null;
  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if ((ch === '"' || ch === "'") && !inQuotes) { inQuotes = true; quoteChar = ch; continue; }
    if (ch === quoteChar && inQuotes) { inQuotes = false; quoteChar = null; continue; }
    if (ch === ' ' && !inQuotes) { if (current) { res.push(current); current=''; } continue; }
    current += ch;
  }
  if (current) res.push(current);
  return res;
}

/* ------------------ controls: api-key ------------------ */

const apiKeyInput = document.getElementById('api-key-input');
apiKeyInput.value = localStorage.getItem(API_KEY_STORAGE_KEY) || '';

document.getElementById('btn-save-key').addEventListener('click', () => {
    const key = apiKeyInput.value.trim();
    if (key) {
        localStorage.setItem(API_KEY_STORAGE_KEY, key);
        term.write(`\r\n${AI_COLOR}API Key saved to browser storage.${RESET_COLOR}`);
    } else {
        localStorage.removeItem(API_KEY_STORAGE_KEY);
        term.write(`\r\n${AI_COLOR}API Key removed from browser storage.${RESET_COLOR}`);
    }
    printPrompt();
});
  </script>
</body>
</html>
